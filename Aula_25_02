IA - Técnicas ou metodologia
  - SISTEMAS DE COMPORTAMENTO INTELIGENTE
    - base de conhecimento
      - armazenamento de experiência
    - motor de raciocínio / raciocínio automatizado (dedução, indução)
      - métodos de busca (força bruta; SMA)
        cegos: amplitude e profundidade
        heurísticos: subida de encosta, guloso, A*, Algoritmos Genéticos
    - Aprendizado de máquina - reconhecer padrões por repetição
      - redes neurais

- MÉTODOS DE BUSCA
  - Modelagem do problema/ Solução
    1) Estados(inicial,construtor, intermediários/construtor2, final)
    2) Regras de transição -> métodos que modificam o objeto
    3) Restrição (estado que não pode ser gerado)
    4) Visitados (lista ou uma árvore ou um hashmap)
    5) Função objetivo

A) Problema das Torres de Hannoi
Estados
//Toda pilha tem os seguintes comandos: empty,peek,push/add,pop,remove
  Stack t1 = new Stack();
  Stack t2 = new Stack();
  Stack t3 = new Stack();

Estado.Inicial
  t1.push(3)
  t1.push(2)
  t1.push(1)

Estado Final ou Função Objetivo/Meta
  t1.empty() && t2.empty()

Regras de Transição
  r1 - mover t1 para t2
  if (ehValido(t1,t2))
  {
    public void MoverT1_T2() {
      t2.push(t1.pop());
    }
    Estado novo = new Estado(t1,t2,t3,"movendo topo t1 para o t2")
    if (!visitados.contains(novo))
    {
      visitados.push(novo)
    }
  }

  r2 - mover t1 para t3
  if (ehValido(t1,t3))
  {
    public void MoverT1_T3() {
      t3.push(t1.pop());
    }
  }

  r3 - mover t2 para t1
  if (ehValido(t2,t1))
  {
    public void MoverT2_T1() {
      t1.push(t2.pop());
    }
  }

  r4 - mover t2 para t3
  if (ehValido(t2,t3))
  {
    public void MoverT2_T3() {
      t3.push(t2.pop());
    }
  }

  r5 - mover t3 para t1
  if (ehValido(t3,t1))
  {
    public void MoverT3_T1() {
      t1.push(t3.pop());
    }
  }

  r6 - mover t3 para t2
  if (ehValido(t3,t2))
  {
    public void MoverT3_T2 () {
      t2.push(t3.pop());
    }
  }

Restrição
  public boolean ehValido(Stack Origem,Stack Destino)
  {
    if (Origem.empty())
    {
      return false;
    }

    if ((int)Origem.peek() > (int)Destino.peek())
    {
      return false;
    }

    return true;
  }

Visitados - Lista ou arvore ou hashmap
["[321][][]" , "[32][1][]"]



Problemas das Jarras

jarra1 suporta 4 litros
jarra2 suporta 3 litros
Torneia que jorra agua infinita

Objetivo: deixar em uma das jarras 2 litros

class Estado()
{
  int jarra1
  int jarra2

  public Estado(int j1,int j2)
  {
    this.j1 = j1;
    this.j2 = j2;
  }

  public boolean ehMeta()
  {
    return((this.j1 == 2 && this.j2 == 0) || (this.j1 == 0 && this.j2 == 2 ))
  }


  public void Encherj1()
  {
    this.j1 = 3;
  }

  public void Encherj2()
  {
    this.j2 = 3;
  }

  public void esvaziarJ1()
  {
    this.j1 = 0;
  }

  public void esvaziarJ2()
  {
    this.j2 = 0;
  }


  public void DespejarJ2_J1()
  {
    int j1 = this.j1;
    int j2 = this.j2;

    if(j2 > (4 - j1))
    {
      j2 = j2 - (4 - j1);
      j1 = 4;
    }else
    {
      j1 = j1 + j2;
      j2 = 0;
    }

    Estado novo = new Estado(j1,j2);
    if (!visitados.contains(novo))
    {
      visitados.add(novo);
    }
    
  }
}

class Roda() 
{
  psvm()
{
  
}
}
